package main
// vim: et ts=4 sw=4 sr smartindent:

import (
    "flag"
    "fmt"
    "os"
)

// ... exit error codes
const err_args = 2

// option help messages
const hmsg_i = "skip any file/dir that already exists at the path for a gitdep to be cloned"
const hmsg_m = "how many nested levels of cloned gitdeps to keep processing"
const hmsg_s = "initial dir to start processing gitdeps"

// note that subcmd (not cmd) usage msg is generated by flag pkg
const cmd_usage = `Usage: %s <subcmd> <opts>:

<subcmd>: get | verify

%s <subcmd> -help: context help for subcmd options.

IMPORTANT: precede options with single not double dashes
`

type Cmd struct {
    Subcmd         string // get | verify
    IgnoreExisting bool   // see hmsg_i
    MaxLevel       int    // see hmsg_m
    StartDir       string // see hmsg_s
}

func NewCmd() (c *Cmd) {

    c, err := MakeCmd()
    if err != nil {
        fmt.Println(err)
        os.Exit(err_args)
    }

    return c
}

// MakeCmd - validates cmd and any subcmd opts from command line
// Returns: pointer to struct defining characteristics for this subcmd
func MakeCmd() (p *Cmd, err error) {

    var c Cmd // struct we'll modify
    p = &c    // pointer we'll return

    cmd := os.Args[0]

    if len(os.Args) < 2 { // Args[0]: binary  Args[1]: subcmd
        err = fmt.Errorf(cmd_usage, cmd, cmd)
        return p, err
    }

    subcmd := os.Args[1]
    curr_dir, _  := os.Getwd()

    argset := flag.NewFlagSet(cmd + " " + subcmd, flag.ExitOnError)

    // -start-dir is opt common to all subcmds
    s := argset.String("start-dir", curr_dir, hmsg_s)

    c.Subcmd = subcmd

    switch subcmd {
        case "-help":
            fmt.Printf(cmd_usage, cmd, cmd)
            os.Exit(0)
        case "get":
            i := argset.Bool("ignore-existing", false, hmsg_i)
            m := argset.Int("max-level", 3, hmsg_m)

            argset.Parse(os.Args[2:])

            c.IgnoreExisting = *i
            c.MaxLevel       = *m
            c.StartDir       = *s

        case "verify":
            argset.Parse(os.Args[2:])

            c.IgnoreExisting = false
            c.MaxLevel       = 0
            c.StartDir       = *s
        default:
            err_msg := fmt.Sprintf(cmd_usage, cmd, cmd)
            err = fmt.Errorf("%q is not valid command.\n%s", subcmd, err_msg)
    }
    return p, err
}
